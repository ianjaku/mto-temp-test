import * as HTTPStatusCode from "http-status-codes";
import { AppRoute, HTTPVerb } from "../../routes";
import {
    fromBody,
    fromParams,
    validateAccountId,
    validateArrayInput,
    validateBinderId,
    validateDomain,
    validateStringInput,
} from "../../validation";
import {
    validateDeleteSemanticLinkFilter,
    validateGetDomainFiltersForAccountsOptions,
    validateIPWhitelist,
    validateReaderBranding,
    validateSemanticLink,
    validateSemanticLinkRequest,
} from "./validation";
import { RoutingServiceContract } from "./contract";

export default function getRoutes(): { [name in keyof RoutingServiceContract]: AppRoute; } {
    return {
        getBrandingForReaderDomain: {
            description: "Get the branding for a reader domain",
            path: "/branding/:domain",
            verb: HTTPVerb.GET,
            validationRules: [
                [fromParams, "domain", validateDomain]
            ],
            successStatus: HTTPStatusCode.OK
        },
        setBrandingForReaderDomain: {
            description: "Set the branding for a reader domain",
            path: "/branding/:domain",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromParams, "domain", validateDomain]
            ],
            successStatus: HTTPStatusCode.NO_CONTENT
        },
        getAccountIdsForDomain: {
            description: "Retrieve the account ids for a domain",
            path: "/domains/:domain/accounts",
            verb: HTTPVerb.GET,
            validationRules: [
                [fromParams, "domain", validateDomain]
            ],
            successStatus: HTTPStatusCode.OK
        },
        getAccountsForDomain: {
            description: "Retrieve the accounts (summaries) for a domain",
            path: "/domains/:domain/accountsummaries",
            verb: HTTPVerb.GET,
            validationRules: [
                [fromParams, "domain", validateDomain]
            ],
            successStatus: HTTPStatusCode.OK
        },
        getSemanticLinkById: {
            description: "Retrieve semantic links based on filter",
            path: "/semanticlink/:domain/",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromParams, "domain", validateDomain]
            ],
            successStatus: HTTPStatusCode.OK
        },
        findSemanticLinks: {
            description: "Retrieve semantic links for given binderId",
            path: "/semanticlinkfind",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromBody, "binderId", validateBinderId]
            ],
            successStatus: HTTPStatusCode.OK
        },
        findSemanticLinksMulti: {
            description: "Retrieve semantic links for given binderIds",
            path: "/findSemanticLinksMulti",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromBody, "binderIds", validateArrayInput("binderIds", validateBinderId)]
            ],
            successStatus: HTTPStatusCode.OK
        },
        ensureSemanticLinks: {
            description: "Ensure autogenerated semantic links are set for given slugs",
            path: "/semanticlinks/ensure",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromBody, "semanticLinkRequests", validateArrayInput("semanticLinkRequests", validateSemanticLinkRequest)],
            ],
            successStatus: HTTPStatusCode.OK
        },
        identifyLanguageInSemanticLinks: {
            description: "Updates any semantic links with undefined language codes to given languageCode",
            path: "/semanticlinks/identifylanguage",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromBody, "domain", validateStringInput],
                [fromBody, "itemId", validateStringInput],
                [fromBody, "languageCode", validateStringInput],
            ],
            successStatus: HTTPStatusCode.OK
        },
        setSemanticLink: {
            description: "Set (upsert) given semantic link",
            path: "/semanticlink",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromBody, "semanticLink", validateSemanticLink],
            ],
            successStatus: HTTPStatusCode.OK
        },
        deleteSemanticLinks: {
            description: "Delete all the semantic links based on given filter",
            path: "/semanticlinks",
            verb: HTTPVerb.DELETE,
            validationRules: [
                [fromBody, "filter", validateDeleteSemanticLinkFilter],
            ],
            successStatus: HTTPStatusCode.OK
        },
        updateReaderBranding: {
            description: "Update an existing reader branding",
            path: "/brandings/:id",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromParams, "id", validateStringInput],
                [fromBody, "branding", validateReaderBranding],
            ],
            successStatus: HTTPStatusCode.OK
        },
        listBrandings: {
            description: "List the available brandings",
            path: "/brandings",
            verb: HTTPVerb.GET,
            validationRules: [],
            successStatus: HTTPStatusCode.OK
        },
        listDomainFilters: {
            description: "List the domain filters",
            path: "/domainfilters",
            verb: HTTPVerb.GET,
            validationRules: [],
            successStatus: HTTPStatusCode.OK
        },
        deleteDomainFilter: {
            description: "Deletes a domain filter",
            path: "/domainfilters/:domain",
            verb: HTTPVerb.DELETE,
            validationRules: [
                [fromParams, "domain", validateDomain],
            ],
            successStatus: HTTPStatusCode.OK
        },
        createReaderBranding: {
            description: "Create a new reader branding",
            path: "/brandings",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromBody, "branding", validateReaderBranding],
            ],
            successStatus: HTTPStatusCode.OK
        },
        deleteReaderBranding: {
            description: "Delete a reader branding",
            path: "/brandings",
            verb: HTTPVerb.DELETE,
            validationRules: [
                [fromBody, "branding", validateReaderBranding],
            ],
            successStatus: HTTPStatusCode.OK
        },
        setDomainsForAccount: {
            description: "Set the domain filters for an account by passing in a list of domains",
            path: "/domains",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromBody, "accountId", validateAccountId],
                [fromBody, "domains", validateArrayInput("domains", validateDomain)]
            ],
            successStatus: HTTPStatusCode.OK
        },
        getDomainFiltersForAccounts: {
            description: "Gets the domain filters for a given account",
            path: "/domainfilters",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromBody, "accountIds", validateArrayInput("accountIds", validateAccountId)],
                [fromBody, "options", validateGetDomainFiltersForAccountsOptions, "optional"],
            ],
            successStatus: HTTPStatusCode.OK
        },
        getDomainFilterByDomain: {
            description: "Translates a given domain to its domain filter",
            path: "/domainfilters/:domain",
            verb: HTTPVerb.GET,
            validationRules: [
                [fromParams, "domain", validateDomain]
            ],
            successStatus: HTTPStatusCode.OK
        },
        getIpWhitelist: {
            description: "Get the ip whitelist configuration for the domain",
            path: "/ipwhitelists/:domain",
            verb: HTTPVerb.GET,
            validationRules: [
                [fromParams, "domain", validateDomain]
            ],
            successStatus: HTTPStatusCode.OK
        },
        saveIpWhitelist: {
            description: "Save the ipwhite list",
            path: "/ipwhitelists",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromBody, "ipwhitelist", validateIPWhitelist]
            ],
            successStatus: HTTPStatusCode.OK
        },
        relabelLanguageInSemanticLinks: {
            description: "",
            path: "/semanticlinkrelabel",
            verb: HTTPVerb.POST,
            validationRules: [
                [fromBody, "domain", validateDomain],
                [fromBody, "itemId", validateStringInput],
                [fromBody, "fromLanguageCode", validateStringInput],
                [fromBody, "toLanguageCode", validateStringInput]
            ],
            successStatus: HTTPStatusCode.OK
        },
    };
}