import * as React from "react";
import { IWebData, WebDataState } from "@binders/client/lib/webdata";
import { deleteSemanticLink, updateSemanticLink } from "../actions";
import AccountStore from "../../../../../accounts/store";
import AddCircle from "@binders/ui-kit/lib/elements/icons/AddCircle";
import CircularProgress from "@binders/ui-kit/lib/elements/circularprogress";
import ContextMenu from "@binders/ui-kit/lib/elements/contextmenu";
import Copy from "@binders/ui-kit/lib/elements/icons/Copy";
import { CopyToClipboard } from "react-copy-to-clipboard";
import Delete from "@binders/ui-kit/lib/elements/icons/Delete";
import { FEATURE_QR_CODE_LOGO } from "@binders/client/lib/clients/accountservice/v1/contract";
import { FlashMessages } from "../../../../../logging/FlashMessages";
import LanguageCodeCircle from "../../LanguageCodeCircle";
import Lock from "@binders/ui-kit/lib/elements/icons/Lock";
import LockOpen from "@binders/ui-kit/lib/elements/icons/LockOpen";
import MenuItem from "@binders/ui-kit/lib/elements/contextmenu/MenuItem";
import Modal from "@binders/ui-kit/lib/elements/modal";
import QRCodeSimple from "@binders/ui-kit/lib/elements/icons/QRCodeSimple";
import {
    QrCodeAndShareLinks
} from "@binders/ui-kit/lib/elements/qrCodeAndShareLinks/QrCodeAndShareLinks";
import SemanticLinkManagerInput from "./SemanticLinkManagerInput";
import { SemanticLinkRow } from "../SemanticLinkManagerSet";
import { TranslationKeys as TK } from "@binders/client/lib/react/i18n/translations";
import View from "@binders/ui-kit/lib/elements/icons/View";
import cx from "classnames";
import { generateDocumentLink } from "@binders/client/lib/binders/readerPath";
import { omit } from "ramda";
import { useFluxStoreAsAny } from "@binders/client/lib/react/helpers/hooks";
import { useShowModal } from "@binders/ui-kit/lib/compounds/modals/ModalViewProvider";
import { useTranslation } from "@binders/client/lib/react/i18n";

const { useState, useMemo } = React;

interface IProps {
    semanticLinkRow: SemanticLinkRow;
    firstInSet?: boolean;
    setIsFakeSemlinkShown: (shown: boolean) => void;
    unpublishedLangCodes?: string[];
    widthRestriction?: number;
}

const SemanticLinkManagerRow: React.FC<IProps> = ({
    firstInSet,
    semanticLinkRow,
    setIsFakeSemlinkShown,
    unpublishedLangCodes,
    widthRestriction,
}) => {

    const ctxMenuRef = React.useRef(null);
    const accountFeaturesWD: IWebData<string[]> = useFluxStoreAsAny(AccountStore, (_prevState, store) => store.getAccountFeatures());
    const accountFeatures = useMemo(() => accountFeaturesWD.state === WebDataState.SUCCESS && accountFeaturesWD.data, [accountFeaturesWD]);
    const useLogo = useMemo(() => accountFeatures.includes(FEATURE_QR_CODE_LOGO), [accountFeatures]);

    const [isLoading, setIsLoading] = useState(false);
    const fullUrl = useMemo(() => generateDocumentLink(semanticLinkRow), [semanticLinkRow]);

    const { t } = useTranslation();

    const showQrCodeModal = useShowModal(({ hide }) => (
        <Modal
            title={semanticLinkRow.semanticId}
            classNames="modal-qr-code"
            onHide={hide}
            zIndexBump={100}
        >
            <QrCodeAndShareLinks
                link={fullUrl}
                useLogo={useLogo}
            />
        </Modal>
    ));

    const renderBody = React.useCallback(() => (
        <div className="semanticLinkManager-row-body">
            <SemanticLinkManagerInput
                semanticLinkRow={semanticLinkRow}
                setIsLoading={setIsLoading}
                setIsFakeSemlinkShown={setIsFakeSemlinkShown}
                unpublishedLangCodes={unpublishedLangCodes || []}
                widthRestriction={widthRestriction}
                documentLink={fullUrl}
            />
        </div>
    ), [semanticLinkRow, setIsFakeSemlinkShown, unpublishedLangCodes, widthRestriction, fullUrl]);

    const isAutoGeneratedLink = React.useMemo(() =>
        new RegExp(/-\d{4}$/).test(semanticLinkRow.semanticId), [semanticLinkRow]);

    const onSoftDelete = React.useCallback(async () => {
        setIsLoading(true);
        await updateSemanticLink(omit(["isFake"], { ...semanticLinkRow, deleted: true }), t);
        setIsLoading(false);
    }, [semanticLinkRow, t]);

    const onSoftUndelete = React.useCallback(async () => {
        setIsLoading(true);
        await updateSemanticLink(omit(["isFake"], { ...semanticLinkRow, deleted: false }), t);
        setIsLoading(false);
    }, [semanticLinkRow, t]);

    const onHardDelete = React.useCallback(async () => {
        setIsLoading(true);
        await deleteSemanticLink(omit(["isFake"], { ...semanticLinkRow }));
        setIsLoading(false);
    }, [semanticLinkRow]);

    const onFollow = React.useCallback(async () => {
        window.open(fullUrl, "_blank");
    }, [fullUrl]);

    const renderContextMenu = React.useCallback(() => {
        if (semanticLinkRow.isFake) {
            return null;
        }
        return (
            <ContextMenu
                anchorRef={ctxMenuRef}
                menuIconName={"more_vert"}
                renderAbovePopup={true}
                testId={`semanticLinkManagerInput-ctx-trigger-${semanticLinkRow.semanticId}`}
            >
                <MenuItem
                    onClick={() => setIsFakeSemlinkShown(true)}
                    title={t(TK.DocManagement_SemLinkCtxAdd)}
                    icon={AddCircle()}
                />
                {semanticLinkRow.deleted ?
                    (
                        <MenuItem
                            onClick={onSoftUndelete}
                            title={t(TK.DocManagement_SemLinkCtxLock)}
                            icon={Lock()}
                        />
                    ) :
                    null}
                {semanticLinkRow.deleted ?
                    (
                        <MenuItem
                            onClick={onHardDelete}
                            title={t(TK.DocManagement_SemLinkCtxDelete)}
                            icon={Delete()}
                        />
                    ) :
                    null}

                {!semanticLinkRow.deleted ?
                    (
                        <MenuItem
                            onClick={onSoftDelete}
                            title={t(TK.DocManagement_SemLinkCtxUnlock)}
                            icon={LockOpen()}
                        />
                    ) :
                    null}

                <MenuItem
                    title={t(TK.DocManagement_SemLinkCtxCopy)}
                    icon={<Copy />}
                    wrapper={(children) => (
                        <CopyToClipboard
                            text={fullUrl}
                            onCopy={(_txt, success) => {
                                if (success) {
                                    FlashMessages.success(t(TK.DocManagement_QrCopySuccess));
                                }
                            }}
                        >
                            {children}
                        </CopyToClipboard>
                    )}
                />
                <MenuItem
                    onClick={onFollow}
                    title={t(TK.DocManagement_SemLinkCtxFollow)}
                    icon={<View />}
                />
                <MenuItem
                    onClick={() => showQrCodeModal()}
                    title={t(TK.DocManagement_SemLinkCtxQr)}
                    icon={QRCodeSimple()}
                    testId="semanticLinkManagerInput-ctx-item-qr"
                />
            </ContextMenu >
        );
    }, [semanticLinkRow, t, onSoftUndelete, onHardDelete, onSoftDelete, onFollow, setIsFakeSemlinkShown, fullUrl, showQrCodeModal]);

    const renderRightControl = React.useCallback(() => {
        return (
            <div className="semanticLinkManager-row-rightctrl">
                {isLoading ? CircularProgress() : renderContextMenu()}
            </div>
        )
    }, [isLoading, renderContextMenu]);

    const maybeRenderLanguageCode = React.useCallback(() => {
        return (
            <div className="semanticLinkManager-row-langCode">
                {firstInSet ?
                    (
                        <LanguageCodeCircle languageCode={semanticLinkRow.languageCode} />
                    ) :
                    null}
            </div>
        )
    }, [firstInSet, semanticLinkRow]);

    return (
        <div className={cx(
            "semanticLinkManager-row",
            {
                "semanticLinkManager-row--accented": !isAutoGeneratedLink,
            }
        )} ref={ctxMenuRef}>
            {maybeRenderLanguageCode()}
            {renderBody()}
            {renderRightControl()}
        </div>
    )
}

export default SemanticLinkManagerRow;